// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: command.sql

package sqlc

import (
	"context"
)

const commandCancelByStatusQueuedAndProcessing = `-- name: CommandCancelByStatusQueuedAndProcessing :exec
UPDATE commands
SET status = 'CANCELED'
WHERE status IN ('QUEUED', 'PROCESSING')
`

func (q *Queries) CommandCancelByStatusQueuedAndProcessing(ctx context.Context, db DBTX) error {
	_, err := db.ExecContext(ctx, commandCancelByStatusQueuedAndProcessing)
	return err
}

const commandCancelByStatusQueuedAndProcessingAndCreatedByCloud = `-- name: CommandCancelByStatusQueuedAndProcessingAndCreatedByCloud :exec
UPDATE commands
SET status = 'CANCELED'
WHERE status IN ('QUEUED', 'PROCESSING')
AND source = 'CLOUD'
`

func (q *Queries) CommandCancelByStatusQueuedAndProcessingAndCreatedByCloud(ctx context.Context, db DBTX) error {
	_, err := db.ExecContext(ctx, commandCancelByStatusQueuedAndProcessingAndCreatedByCloud)
	return err
}

const commandCreate = `-- name: CommandCreate :one
INSERT INTO commands (
	type,
	status,
	source,
	inputs,
	error,
	started_at,
	created_at,
	updated_at,
	completed_at
)
VALUES (
	?1,
	?2,
	?3,
	?4,
	?5,
	?6,
	?7,
	?8,
	?9
)
RETURNING id, outputs
`

type CommandCreateParams struct {
	Type        string  `json:"type"`
	Status      string  `json:"status"`
	Source      string  `json:"source"`
	Inputs      string  `json:"inputs"`
	Error       *string `json:"error"`
	StartedAt   *string `json:"started_at"`
	CreatedAt   string  `json:"created_at"`
	UpdatedAt   string  `json:"updated_at"`
	CompletedAt *string `json:"completed_at"`
}

type CommandCreateRow struct {
	ID      int64  `json:"id"`
	Outputs string `json:"outputs"`
}

func (q *Queries) CommandCreate(ctx context.Context, db DBTX, arg CommandCreateParams) (CommandCreateRow, error) {
	row := db.QueryRowContext(ctx, commandCreate,
		arg.Type,
		arg.Status,
		arg.Source,
		arg.Inputs,
		arg.Error,
		arg.StartedAt,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.CompletedAt,
	)
	var i CommandCreateRow
	err := row.Scan(&i.ID, &i.Outputs)
	return i, err
}

const commandDeleteByIDAndNotProcessing = `-- name: CommandDeleteByIDAndNotProcessing :execrows
DELETE FROM commands
WHERE id = ?1
AND status != 'PROCESSING'
`

func (q *Queries) CommandDeleteByIDAndNotProcessing(ctx context.Context, db DBTX, id int64) (int64, error) {
	result, err := db.ExecContext(ctx, commandDeleteByIDAndNotProcessing, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const commandDeleteOldCommands = `-- name: CommandDeleteOldCommands :execrows
DELETE FROM commands
WHERE created_at < ?1
AND status NOT IN ('QUEUED', 'PROCESSING')
`

func (q *Queries) CommandDeleteOldCommands(ctx context.Context, db DBTX, createdAt string) (int64, error) {
	result, err := db.ExecContext(ctx, commandDeleteOldCommands, createdAt)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const commandGetByID = `-- name: CommandGetByID :one
SELECT id, type, status, source, inputs, error, completed_at, created_at, updated_at, started_at, outputs FROM commands
WHERE id = ?1
`

func (q *Queries) CommandGetByID(ctx context.Context, db DBTX, id int64) (Command, error) {
	row := db.QueryRowContext(ctx, commandGetByID, id)
	var i Command
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Status,
		&i.Source,
		&i.Inputs,
		&i.Error,
		&i.CompletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.StartedAt,
		&i.Outputs,
	)
	return i, err
}

const commandGetNextExecutable = `-- name: CommandGetNextExecutable :one
SELECT id, type, status, source, inputs, error, completed_at, created_at, updated_at, started_at, outputs FROM commands
WHERE
	status IN ('QUEUED', 'PROCESSING')
ORDER BY
	CASE status
		WHEN 'PROCESSING' THEN 0
		WHEN 'QUEUED' THEN 1
	END ASC,
	created_at ASC
LIMIT 1
`

func (q *Queries) CommandGetNextExecutable(ctx context.Context, db DBTX) (Command, error) {
	row := db.QueryRowContext(ctx, commandGetNextExecutable)
	var i Command
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Status,
		&i.Source,
		&i.Inputs,
		&i.Error,
		&i.CompletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.StartedAt,
		&i.Outputs,
	)
	return i, err
}

const commandGetProcessing = `-- name: CommandGetProcessing :one
SELECT id, type, status, source, inputs, error, completed_at, created_at, updated_at, started_at, outputs FROM commands
WHERE status = 'PROCESSING'
LIMIT 1
`

func (q *Queries) CommandGetProcessing(ctx context.Context, db DBTX) (Command, error) {
	row := db.QueryRowContext(ctx, commandGetProcessing)
	var i Command
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Status,
		&i.Source,
		&i.Inputs,
		&i.Error,
		&i.CompletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.StartedAt,
		&i.Outputs,
	)
	return i, err
}

const commandProcessingExists = `-- name: CommandProcessingExists :one
SELECT EXISTS (
	SELECT 1 FROM commands
	WHERE status = 'PROCESSING'
)
`

func (q *Queries) CommandProcessingExists(ctx context.Context, db DBTX) (int64, error) {
	row := db.QueryRowContext(ctx, commandProcessingExists)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const commandUpdate = `-- name: CommandUpdate :one
UPDATE commands
SET
	status = CASE WHEN ?1 = 1 THEN ?2 ELSE status END,
	outputs = CASE WHEN ?3 = 1 THEN ?4 ELSE outputs END,
	error = CASE WHEN ?5 = 1 THEN ?6 ELSE error END,
	started_at = CASE WHEN ?7 = 1 THEN ?8 ELSE started_at END,
	completed_at = CASE WHEN ?9 = 1 THEN ?10 ELSE completed_at END,
	updated_at = ?11
WHERE id = ?12
RETURNING id, type, status, source, inputs, error, completed_at, created_at, updated_at, started_at, outputs
`

type CommandUpdateParams struct {
	SetStatus      interface{} `json:"set_status"`
	Status         string      `json:"status"`
	SetOutputs     interface{} `json:"set_outputs"`
	Outputs        string      `json:"outputs"`
	SetError       interface{} `json:"set_error"`
	Error          *string     `json:"error"`
	SetStartedAt   interface{} `json:"set_started_at"`
	StartedAt      *string     `json:"started_at"`
	SetCompletedAt interface{} `json:"set_completed_at"`
	CompletedAt    *string     `json:"completed_at"`
	UpdatedAt      string      `json:"updated_at"`
	ID             int64       `json:"id"`
}

func (q *Queries) CommandUpdate(ctx context.Context, db DBTX, arg CommandUpdateParams) (Command, error) {
	row := db.QueryRowContext(ctx, commandUpdate,
		arg.SetStatus,
		arg.Status,
		arg.SetOutputs,
		arg.Outputs,
		arg.SetError,
		arg.Error,
		arg.SetStartedAt,
		arg.StartedAt,
		arg.SetCompletedAt,
		arg.CompletedAt,
		arg.UpdatedAt,
		arg.ID,
	)
	var i Command
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Status,
		&i.Source,
		&i.Inputs,
		&i.Error,
		&i.CompletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.StartedAt,
		&i.Outputs,
	)
	return i, err
}
